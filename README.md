## Shell 学习笔记
### Shell 传递参数
```powershell
#！/bin/bash
echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

➜  ShellPractice ./pass_argu.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./pass_argu.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
```
|参数处理|说明|
|-|-|
|\$#|传递到脚本的参数个数|
|\$*|以一个单字符串显示所有向脚本传递的参数。如“\$*”用“括起来的情况、以“\$1 \$2 ... \$n”的形式输出所有参数。|
|\$\$|脚本运行的当前进程ID号|
|\$!|后台运行的最后一个进程ID号|
|\$@|与\$*相同，但是使用时加引号，并在引号中返回每个参数。如“\$@”用”括起来的情况、以“\$1” "\$2" ... "\n"的形式输出所有参数。|
|\$-|显示Shell使用的当前选项，与[set命令](http://www.runoob.com/linux/linux-comm-set.html)功能相同。|
|\$?|显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。|

#### \$* 与 \$@的区别：
* 相同点：都是引用所有参数。
* 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数1、2、3，则`"*"`等价于`"1 2 3"`(传递了一个参数)，而`"@"`等价于`"1" "2" "3"`

### 算术运算符
|运算符|说明|举例|
|-|-|-|
|+|加法|`expr $a + $b`|
|-|减法|`expr $a - $b`|
|*|乘法|`expr $a \* $b`|
|/|除法|`expr $b / $a`|
|%|取余|`expr $b % $a`|
|=|赋值|`a=$b`将把变量b的值赋给a。|
|==|相等。用于比较两个数字，相同则返回true。|`[ $a == $b ]`|
|!=|不相等。用于比较两个数字，不相同则返回true。|`[ $a != $b ]`|

> 注意：条件表达式要放在方括号之间，并且要有空格，例如：`[$a==$b]`是错误的，必须写成`[ $a == %b ]`。

### 关系运算符
关系运算符只支持数字，不支持字符串
假设，变量a为10，变量b为20：

|运算符|说明|举例|
|-|-|-|
|-eq|检测两个数是否相等，相等返回true。|`[ $a -eq $b ]`返回false。|
|-ne|检测两个数是否不相等，不相等返回true。|`[ $a -ne $b ]`返回true。|
|-gt|检测左边的数是否大于右边的，如果是，则返回true。|`[ $a -gt $b ]`返回false。|
|-lt|检测左边的数是否小于右边的，如果是，则返回true。|`[ $a -lt $b ]`返回true。|
|-ge|检测左边的数是否大于等于右边的，如果是，则返回true。|`[ $a -ge $b ]`返回false。|
|-le|检测左边的数是否小于等于右边的，如果是，则返回true。|`[ $a -le $b ]`返回true。|

### 布尔运算符
还是假设，变量a为10，变量b为20：

|运算符|说明|举例|
|-|-|-|
|！|非运算，表达式为true则返回false，否则返回true。|`[ !false ]`返回true。|
|-o|或运算，有一个表达式为true则返回true。|`[ $a -lt 20 -o $b -gt 100]`返回true。|
|-a|与运算，两个表达式都为true才返回true。|`[ $a -lt 20 -a $b -gt 100]`返回false。|

> `-o`和`-a`跟`&&`和`||`效果一样，只不过`-o`和`-a`只能用单大括号括起来，而`&&`和`||`要用双大括号括起来。

### 字符串运算符
假设变量a为“abc”，变量b为“efg”：

|运算符|说明|举例|
|-|-|-|
|=|检测两个字符串是否相等，相等返回true。|`[ $a = $b ]`返回false。|
|!=|检测两个字符串是否相等，不相等返回true。|`[ $a != $b ]`返回true。|
|-z|检测字符串长度是否为0，为0返回true。|`[ -z $a ]`返回false。|
|-n|检测字符串长度是否为0，不为0返回true。|`[ -n $a ]`返回true。|
|str|检测字符串是否为空，不为空返回true。|`[ $a ]`返回ture。|

### 文件测试运算符
|操作符|说明|举例|
|-|-|-|
|-b file|检测文件是否是块设备文件，如果是，则返回 true。|`[ -b $file ]`返回false。|
|-c file|检测文件是否是字符设备文件，如果是，则返回true。|`[ -c $file ]`返回false。|
|-d file|检测文件是否是目录，如果是，则返回true。|`[ -d $file ]`返回false。|
|-f file|检测文件是否是普通文件(既不是目录，也不是设备文件)，如果是，则返回true。|`[ -f $file ]`返回true。|
|-g file|检测文件是否设置了SGID位，如果是，则返回true。|`[ -g $file ]`返回false。|
|-k file|检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。|`[ -k $file ]`返回false。|
|-p file|检测文件是否是有名管道，如果是，则返回 true。|`[ -p $file ]`返回 false。|
|-u file|检测文件是否设置了 SUID 位，如果是，则返回 true。|`[ -u $file ]`返回 false。|
|-r file|检测文件是否可读，如果是，则返回 true。|`[ -r $file ]`返回 true。|
|-w file|检测文件是否可写，如果是，则返回 true。|`[ -w $file ]`返回 true。|
|-x file|检测文件是否可执行，如果是，则返回 true。|`[ -x $file ]`返回 true。|
|-s file|检测文件是否为空（文件大小是否大于0），不为空返回 true。|`[ -s $file ]`返回 true。|
|-e file|检测文件（包括目录）是否存在，如果是，则返回 true。|`[ -e $file ]`返回 true|

### Shell中的函数
|参数处理|说明|
|-|-|
|\$?|获取函数调用后的返回值。|
|\$n或\${n}|获取传递到函数内部的第n个参数，如果n>=10则使用`{}`括起来|
|\$#|传递到脚本的参数个数|
|\$*|以一个单字符串显示所有向脚本传递的参数|
|\$\$|脚本运行的当前进程ID号|
|\$!|后台运行的最后一个进程的ID号|
|\$@|与\$*相同，但是使用时加引号，并在引号中返回每个参数。|
|\$|显示Shell使用的当前选项，与set命令功能相同。|
|\$?|显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。|

### Shell 输入/输出重定向
|命令|说明|
|-|-|
|command > file|将输出重定向到 file。|
|command > file|将输入重定向到 file。|
|command >> file|将输出以追加的方式重定向到 file。|
|n > file|将文件描述符为 n 的文件重定向到 file。|
|n >> file|将文件描述符为 n 的文件以追加的方式重定向到 file。|
|n >& m|将输出文件 m 和 n 合并。|
|n <& m|将输入文件 m 和 n 合并。|
|<< tag|将开始标记 tag 和结束标记 tag 之间的内容作为输入。|

```powershell
# 将stderr内容重定向到file中
$ command 2 > file
# 将stderr内容重定向追加到file中
$ command 2 >> file
# 如果希望将stdout和stderr合并后重定向到file，可以这样写：
$ command > file 2>&1
# 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到/dev/null
$ command > /dev/null
# 如果希望屏蔽stdout和stderr，可以这样写：
$ command > /dev/null 2>&1
```
> `/dev/null`是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是`/dev/null`文件非常有用，将命令的输出重定向到它，会起到**禁止输出**的效果。

> `ls a b 1>f.out 2>&1` #所有(标准输入/标准输出)信息都被输出到f.out
> `ls a b 2>f.out 1>&2` #所有(标准输入/标准输出)信息都被输出到f.out
> 为何2>&1要写在后面？
>
> `command > file 2>&1`
> 首先是`command > file`将标准输出重定向到file中， `2>&1` 是标准错误拷贝了标准输出的行为，也就是同样被重定向到`file`中，最终结果就是标准输出和错误都被重定向到`file`中。
> `command 2>&1 >file`
> `2>&1` 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。`>file` 后输出才被重定向到`file`，但标准错误仍然保持在终端。
